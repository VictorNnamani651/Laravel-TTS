<?php

namespace App\Services;

use Illuminate\Support\Facades\Storage;

class VideoService
{
    protected $ffmpegPath;

    public function __construct()
    {
        $this->ffmpegPath = config('services.ffmpeg.ffmpeg_path', '/usr/bin/ffmpeg');
    }

    /**
     * Generate subtitle file (SRT format)
     */
    public function generateSubtitles(string $text): string
    {
        // Split text into chunks (max 42 characters per line for readability)
        $words = explode(' ', $text);
        $lines = [];
        $currentLine = '';

        foreach ($words as $word) {
            if (strlen($currentLine . ' ' . $word) <= 42) {
                $currentLine .= ($currentLine ? ' ' : '') . $word;
            } else {
                if ($currentLine) {
                    $lines[] = $currentLine;
                }
                $currentLine = $word;
            }
        }
        if ($currentLine) {
            $lines[] = $currentLine;
        }

        // Create SRT content (show each line for proportional time)
        $totalDuration = 15; // 15 seconds
        $timePerLine = $totalDuration / count($lines);
        
        $srtContent = '';
        foreach ($lines as $index => $line) {
            $startTime = $index * $timePerLine;
            $endTime = ($index + 1) * $timePerLine;
            
            $srtContent .= ($index + 1) . "\n";
            $srtContent .= $this->formatSrtTime($startTime) . ' --> ' . $this->formatSrtTime($endTime) . "\n";
            $srtContent .= $line . "\n\n";
        }

        $srtPath = 'subtitles/' . uniqid() . '.srt';
        Storage::put($srtPath, $srtContent);

        return $srtPath;
    }

    /**
     * Format time for SRT (HH:MM:SS,mmm)
     */
    protected function formatSrtTime(float $seconds): string
    {
        $hours = floor($seconds / 3600);
        $minutes = floor(($seconds % 3600) / 60);
        $secs = floor($seconds % 60);
        $milliseconds = ($seconds - floor($seconds)) * 1000;

        return sprintf('%02d:%02d:%02d,%03d', $hours, $minutes, $secs, $milliseconds);
    }

    /**
     * Generate video with Ken Burns effect, subtitles, audio, and watermark
     */
    public function generateVideo(array $imagePaths, string $audioPath, string $subtitlePath, string $text): string
    {
        $outputPath = 'videos/' . uniqid() . '.mp4';
        $fullOutputPath = Storage::path($outputPath);
        
        // Each image shows for 5 seconds (3 images = 15 seconds)
        $imageDuration = 5;
        
        // Create Ken Burns effect for each image
        $filterComplex = [];
        $inputFiles = '';
        
        foreach ($imagePaths as $index => $imagePath) {
            $inputFiles .= '-loop 1 -t ' . $imageDuration . ' -i ' . escapeshellarg(Storage::path($imagePath)) . ' ';
            
            // Ken Burns effect: zoom in and pan
            $scale = $index % 2 == 0 ? '1.0:1.2' : '1.0:1.2'; // zoom from 1.0 to 1.2
            $filterComplex[] = "[{$index}:v]scale=1080:1920:force_original_aspect_ratio=increase,crop=1080:1920,zoompan=z='min(zoom+0.0002,1.2)':d={$imageDuration}*25:s=1080x1920:fps=25[v{$index}]";
        }
        
        // Concatenate videos
        $filterComplex[] = implode('', array_map(fn($i) => "[v{$i}]", range(0, count($imagePaths) - 1))) . "concat=n=" . count($imagePaths) . ":v=1:a=0[outv]";
        
        // Add watermark (text)
        $watermarkText = "Generated by TTS Video";
        $filterComplex[] = "[outv]drawtext=text='{$watermarkText}':fontcolor=white@0.5:fontsize=24:x=10:y=H-th-10[outvw]";
        
        // Add subtitles
        $srtFullPath = Storage::path($subtitlePath);
        $filterComplex[] = "[outvw]subtitles=" . str_replace(':', '\\:', escapeshellarg($srtFullPath)) . ":force_style='Alignment=2,FontName=Arial,FontSize=28,PrimaryColour=&H00FFFFFF,OutlineColour=&H00000000,Outline=2,Shadow=1'[outvsub]";
        
        $filterComplexString = implode(';', $filterComplex);
        
        // FFmpeg command
        $command = sprintf(
            '%s %s -i %s -filter_complex %s -map "[outvsub]" -map %d:a -c:v libx264 -preset medium -crf 23 -c:a aac -b:a 128k -shortest -y %s 2>&1',
            escapeshellcmd($this->ffmpegPath),
            $inputFiles,
            escapeshellarg(Storage::path($audioPath)),
            escapeshellarg($filterComplexString),
            count($imagePaths), // audio input index
            escapeshellarg($fullOutputPath)
        );

        exec($command, $output, $returnCode);

        if ($returnCode !== 0) {
            throw new \Exception('FFmpeg failed: ' . implode("\n", $output));
        }

        return $outputPath;
    }
}